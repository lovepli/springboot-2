# 基于Redis分布式锁实现 “秒杀” 业务

### 秒杀系统的架构设计
> 秒杀系统：是典型的短时间大量突发访问类问题。这类问题有三种优化思路：
> 
> 1. 写入内存而不写入硬盘
> 2. 异步处理而不是同步处理
> 3. 分布式处理


#### 说明上述三种性能优化思路
> 1. 传统的硬盘读写性能太差，SSD固态硬盘比传统硬盘快100倍，而内存又比SSD固态硬盘快10倍以上。因此操作内存性能是传统硬盘的数千倍
，在实际业务处理中把内存的数据持久化到硬盘，防止系统宕机导致数据丢失
> 2. 异步处理：秒杀业务的短时间大并发，在性能负载上有一个明显的波峰和波谷。为了应对短时间的大并发而准备的大量服务器在经济上想当
不合算的。因此，需要化同步为异步，用户写入内存就立即返回。后台启动多个线程从内存池中异步读取数据进行处理。异步处理通常用MQ来实现
> 3. 分布式处理：就是把海量用户的请求分散到多台机器上。一般用hash实现均匀分布。Redis Cluster就是基于Paxos算法的一个处理分布式
请求的方案


### 项目演示说明：
> - 本演示项目中是基于：动态代理的方式，利用注解和反射机制得到分布式锁ID，进行加锁和释放锁操作。采用动态代理是为了能够将锁操作代码
集中在代理中，方便维护。
> - 在实际业务中，可以基于Spring的AOP特性将锁操作代码集中在切面中，当然AOP本质上也是动态代理。

### 使用Redis锁需要注意的问题
> 1. Redis发现锁失败了要如何处理：使用循环请求，循环去获取锁
> 2. 循环请求获取锁时，如果有一个请求获取了锁，其它请求再去获取锁的时候，容易发生抢锁的可能性：在循环获取锁的时候，加入睡眠时间，等待几毫秒在执行
> 3. 锁提前过期时，请求A还没执行完。这是请求B获取了锁，当请求A执行完后，会不会在删除锁时把请求B的锁删除掉：加锁时，存入key里的值是唯一的，在删除锁时，判断key里存入的value值与自己的是否一致

### 参考文档

* [用Redis轻松实现秒杀系统](https://blog.csdn.net/shendl/article/details/51092916)
* [基于redis分布式锁实现“秒杀”](https://blog.csdn.net/u010359884/article/details/50310387)
* [redis加锁的几种实现](https://blog.csdn.net/Dennis_ukagaka/article/details/78072274)
* [分布式锁的作用及实现（Redis）](https://blog.csdn.net/L_BestCoder/article/details/79336986)

### Guides
The following guides illustrate how to use some features concretely:

* [Messaging with Redis](https://spring.io/guides/gs/messaging-redis/)

